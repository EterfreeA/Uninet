# 状态机
以状态衍生状态机，状态机也是状态为设计思想。

## 状态树
状态机既能够管理状态，也能够管理状态机。倘若以状态机管理状态机，则形成层次状态机。将状态机和状态视作节点，层次状态机就是多叉树。可以称为状态树。  
![多叉状态树](image/Polystate%20Tree.png)  
凡是涉及状态树的序列化与反序列化，都采用深度优先遍历方式。如上图状态树的遍历顺序为S-A-A1-A2-B-C-C1-C2。  
自根节点向最底层遍历有效节点，这些有效节点的状态编号形成有效节点路径，又称为有效状态编号向量。若上图状态树的最底层有效节点是状态A2，则有效节点路径是A-A2。

## 组合模式
状态机基于组合模式，不仅易于聚合状态，还易于嵌套状态机。
* 状态抽象类模板State：定义接口并提供默认实现，作为状态树的叶子节点。
* 状态机类模板StateMachine：作为状态树的非叶子节点。
* 过渡类模板Transition：过渡是抽象事物，用于传递信息和指示状态转换。

![UML类图](image/UML.png)

## 构建与销毁
### 构建方式
状态机提供三种构建方式，分别是外部单独添加方式、外部批量添加方式和内部动态添加方式。内部添加方式指状态向所属状态机添加状态，除此之外都称为外部添加方式。

方式|函数|说明
-|-|-
外部单独添加方式|addState|向位于指定路径的状态机添加单状态。
外部批量添加方式|distribute|序列化状态树，生成节点向量并交予状态机，再反序列化状态树，分发节点以构建状态机。
内部动态添加方式|handle/convert|在执行handle处理输入事件，或者执行convert强制转换状态之时，由前状态创建后状态，以过渡实例形式交予状态机。

### 销毁方式
状态机与状态是聚合关系，在销毁状态机之前销毁状态，以防止资源泄漏。状态机支持两种销毁方式，分别是单独移除方式和批量收集方式。

方式|函数|说明
-|-|-
单独移除方式|removeState|从位于指定路径的状态机移除无效状态。
批量收集方式|collect|序列化状态树，收集所有状态实例。

## 备份与还原
在程序运行过程之中，难免会重启进程，或者遇到进程崩溃。为应对这些情况，状态机提供状态的备份与还原方案，本质是序列化与反序列化状态树的有效节点路径。  
对于不同应用场景，以状态机的角度而言，状态模型不同仍然可以结构化，而状态的数据模型不同却无法结构化，状态机不应限制状态的实现。因此仅备份与还原状态树的有效节点路径，而状态的自定义数据由使用者自行备份与还原。  
**特别注意**：除非在还原之时有效状态存在，否则不能采用内部动态添加方式构建状态机。

## 状态转换
状态转换分为三个步骤，首先向状态机指定转换目标，再由状态机控制转换流程，最后状态完成转换行为。如此设计使得状态之间未直接关联，能够降低状态之间的耦合性。  
站在指定目标的角度，既可以由状态机指定目标，也可以由状态指定目标。将状态指定目标视为内部转换，其他指定目标方式视为外部转换。

### 外部转换
外部转换分为设置状态方式和顺序转换方式。
* 设置状态方式：用以初始有效状态，或者切换有效状态，对应于函数setState。
* 顺序转换方式：按照深度优先遍历状态树，持续转换状态至目标状态，对应于函数update。若无目标状态，则持续转换状态，直到最后状态退出，而状态机设为无效状态。

顺序转换方式方式包括两种方法。第一种适用于状态编号有序，依次转换状态至目标状态。第二种基于节点序列，根据序列依次转换状态，此方法更通用，可以多次访问同一节点。

### 内部转换
内部转换分为输入驱动和强制转换两种方式。输入驱动是状态机的核心思想，而强制转换用以弥补输入驱动不足，使状态转换更灵活，不受输入时机限制。
* 输入驱动方式：当状态机发生输入事件时，传递输入事件至有效状态，由当前有效状态处理并返回过渡实例，对应于函数handle。倘若过渡实例持有后续状态，则向状态机添加后续状态，而状态机先触发当前状态的退出事件，再触发后续状态的进入事件。
* 强制转换方式：在非输入驱动之时，由有效状态访问所属状态机，实现侧向或者向上状态转换，对应于函数convert。

**特别注意**：强制转换方式仅限于同状态机的状态转换，跨状态机的强制转换由涉及状态机自行实现。

# 版本
当前版本：v1.0.1  
语言标准：C++98  
创建日期：2021年01月07日  
更新日期：2021年09月18日

## 内容变化
**v1.0.1**
1. 删除无用抽象层。
2. 在添加状态之时，判断是否添加自身，避免循环引用。

## 项目结构
源码只有头文件，放于文件夹include。
* [State.hpp](include/State.hpp)：定义状态抽象类模板State。
* [StateMachine.hpp](include/StateMachine.hpp)：定义状态机类模板StateMachine。
* [Transition.hpp](include/Transition.hpp)：定义过渡类模板Transition。

示例代码文件放于文件夹example。
* [Owner.h](example/Owner.h)：定义属主类和各状态类。
* [Owner.cpp](example/Owner.cpp)：实现属主类和各状态类。
* [test.cpp](example/test.cpp)：测试代码。

# 作者
name：许聪  
mailbox：solifree@qq.com  
CSDN：https://blog.csdn.net/xucongyoushan  
gitee：https://gitee.com/solifree  
github：https://github.com/SolifreeXu
