# 状态机
以状态衍生状态机，状态机也是状态为设计思想，使状态机之间易于聚合嵌套。  
![UML类图](image/UML.png)

状态派生状态机，各类模板说明如下表所示：

类模板|说明
-|-
State|状态抽象类模板，定义接口并提供默认实现，作为状态树的叶子节点。
StateMachine|状态机类模板，作为状态树的非叶子节点。
Transition|过渡类模板。过渡是抽象事物，当转换状态之时，在不同状态之间传递信息。

## 状态树
状态机既能够管理状态，也能够管理状态机。倘若以状态机管理状态机，则形成层次状态机。将状态机和状态视作节点，层次状态机就是多叉树。可以称为状态树。  
![多叉状态树](image/Polystate%20Tree.png)  
凡是涉及状态树的序列化与反序列化，都采用深度优先的遍历方式。如上图状态树的遍历顺序为S-A-A1-A2-B-C-C1-C2。

## 构建与销毁
### 构建方式
状态机提供三种构建方式，分别是外部单独添加方式、外部批量添加方式和内部动态添加方式。

方式|函数|说明
-|-|-
外部单独添加方式|addState|向位于指定路径的状态机添加单状态。
外部批量添加方式|distribute|序列化状态树，生成节点向量并交予状态机，再反序列化状态树，分发节点以构建状态机。
内部动态添加方式|handle/convert|在执行handle处理输入事件，或者执行convert强制转换状态之时，由前状态创建后状态，以过渡实例的形式交予状态机。

### 销毁方式
状态机与状态是聚合关系，在销毁状态机之前，先销毁状态，防止资源泄漏。状态机支持两种销毁方式，分别是单独移除方式和批量收集方式。

方式|函数|说明
-|-|-
单独移除方式|removeState|可以通过removeState移除非当前状态。
批量收集方式|collect|收集所有状态实例。

## 备份与还原
状态机提供备份与还原方案，本质是序列化与反序列化状态树的有效节点路径，即自根节点向最底层遍历有效状态，而形成有效状态编号向量。  
**特别注意**：除非在还原之时，能够保证有效状态存在，否则不应采用内部动态添加方式构建状态机。

## 状态转换
站在指定目标的角度，既可以由状态机指定目标，也可以由状态指定目标。将状态指定目标视为内部转换，其他指定目标方式视为外部转换。

### 外部转换
外部转换分为设置状态方式和顺序转换方式。
* **设置状态方式**：初始有效状态，以及切换有效状态，对应于函数setState。
* **顺序转换方式**：按照一定顺序，深度优先遍历状态树，持续转换状态至目标状态，对应于函数update。
  若无目标状态，则持续转换状态，直到最后状态退出，而状态机设为无效类型。

### 内部转换
内部转换分为输入驱动和强制转换两种方式。
* **输入驱动方式**：当状态机发生输入事件之时，传给当前状态处理，返回过渡实例作为处理结果，对应于函数handle。
  倘若过渡实例持有后续状态，则向状态机添加后续状态。而状态机先触发当前状态的退出事件，再触发后续状态的进入事件。
* **强制转换方式**：在非输入驱动之时，由当前状态访问所属状态机，主动转换为后续状态，对应于函数convert。
  强制转换方式仅限于同一状态机的状态转换，跨状态机的强制转换由涉及的状态机自行实现。

## 项目结构
源码只含头文件，放于文件夹include。

文件|说明
-|-
[State.hpp](include/State.hpp)|定义状态抽象类模板State。
[StateMachine.hpp](include/StateMachine.hpp)|定义状态机类模板StateMachine。
[Transition.hpp](include/Transition.hpp)|定义过渡类模板Transition。

示例代码文件放于文件夹example。

文件|说明
-|-
[Owner.hpp](example/Owner.hpp)|定义属主类和各状态类。
[Owner.cpp](example/Owner.cpp)|实现属主类和各状态类。
[test.cpp](example/test.cpp)|测试代码。

## 作者
name：许聪  
mailbox：solifree@qq.com  
CSDN：https://blog.csdn.net/xucongyoushan  
gitee：https://gitee.com/solifree  
github：https://github.com/SolifreeXu
